import{_ as s,c as a,o as n,a2 as p}from"./chunks/framework.C9InrCCS.js";const k=JSON.parse('{"title":"快速开始","description":"","frontmatter":{},"headers":[],"relativePath":"zh/quickstart.md","filePath":"zh/quickstart.md"}'),e={name:"zh/quickstart.md"},l=p(`<h1 id="快速开始" tabindex="-1">快速开始 <a class="header-anchor" href="#快速开始" aria-label="Permalink to &quot;快速开始&quot;">​</a></h1><p>这里为您提供了一些项目例子，供您快速开始。理论上，只要保证 app 包能正常运行您定义的 <code>模块</code> ，那么任何目录结构都是可行的。</p><h2 id="http服务" tabindex="-1">http服务 <a class="header-anchor" href="#http服务" aria-label="Permalink to &quot;http服务&quot;">​</a></h2><p>克隆代码到本地</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> step1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --single-branch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git@github.com:zeddy-go/quickstart.git</span></span></code></pre></div><p>我们可以看到如下目录结构</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>.</span></span>
<span class="line"><span>├── conf                       //配置</span></span>
<span class="line"><span>│   ├── config.go</span></span>
<span class="line"><span>│   └── config.yaml</span></span>
<span class="line"><span>├── go.mod</span></span>
<span class="line"><span>├── go.sum</span></span>
<span class="line"><span>├── main.go                     //入口文件</span></span>
<span class="line"><span>└── module                      //模块</span></span>
<span class="line"><span>    └── user                    //用户模块</span></span>
<span class="line"><span>        ├── iface               //接口层</span></span>
<span class="line"><span>        │     └── http          //http接口</span></span>
<span class="line"><span>        │         └── user.go   //user handler</span></span>
<span class="line"><span>        └── module.go           //模块入口</span></span></code></pre></div><p>我们使用embed的方式来加载配置，然后通过环境变量来对配置做改动。 这种方式在容器化部署的场景下非常方便。</p><p>我们引用了 ginx 模块和 user 模块。 ginx 模块为框架内置模块，用于处理 http 请求，底层使用 gin 。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>您完全可以使用任何您喜欢的http库编写自己的http处理模块。或者自己造轮子💯。</p></div><p>user 模块则是我们自己的业务模块。 user 模块实现了一个 handler 方法，当接收到请求时，该方法会输出 hello xxxx! 的JSON响应(module/user/iface/http/user.go)。 接着，它向 ginx 模块注册了一个路由，以接收对应的请求(module/user/module.go:30)。</p><p>在这里您会注意到 container.Invoke 方法。没错，框架使用了<code>依赖注入</code>。 (我们正尝试在开发效率和执行效率之间找到平衡。) 而对象的实例化方法则是在上面的Init方法中进行绑定(module/user/module.go:21)。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>请在Init方法中绑定实例化方法，在Boot方法中或其他地方使用他们。</p></div><p>启动服务 <code>go run .</code> ，然后访问 <a href="http://localhost:8080/hello?username=zed" target="_blank" rel="noreferrer">http://localhost:8080/hello?username=zed</a> 。</p><h2 id="更完整的例子" tabindex="-1">更完整的例子 <a class="header-anchor" href="#更完整的例子" aria-label="Permalink to &quot;更完整的例子&quot;">​</a></h2><p>克隆代码到本地</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> step2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --single-branch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git@github.com:zeddy-go/quickstart.git</span></span></code></pre></div><p>在这个例子中，目录结构如下:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>.</span></span>
<span class="line"><span>├── config                                //配置</span></span>
<span class="line"><span>│   ├── config.go</span></span>
<span class="line"><span>│   └── config.yaml</span></span>
<span class="line"><span>├── docker-compose.yaml                   //这个例子使用docker来启动MySQL数据库</span></span>
<span class="line"><span>├── go.mod</span></span>
<span class="line"><span>├── go.sum</span></span>
<span class="line"><span>├── main.go                               //入口文件</span></span>
<span class="line"><span>└── module</span></span>
<span class="line"><span>    └── user</span></span>
<span class="line"><span>        ├── domain                        //领域层</span></span>
<span class="line"><span>        │         ├── contract.go         //一些接口</span></span>
<span class="line"><span>        │         ├── svc                 //服务</span></span>
<span class="line"><span>        │         │     └── user.go</span></span>
<span class="line"><span>        │         └── user.go             //领域实体</span></span>
<span class="line"><span>        ├── iface                         //接口层</span></span>
<span class="line"><span>        │         └── http</span></span>
<span class="line"><span>        │               ├── payload.go</span></span>
<span class="line"><span>        │               └── user.go       //用户 handler</span></span>
<span class="line"><span>        ├── infra</span></span>
<span class="line"><span>        │         ├── migration           //迁移</span></span>
<span class="line"><span>        │         │     ├── 20240408063653_create_users_table.down.sql</span></span>
<span class="line"><span>        │         │     ├── 20240408063653_create_users_table.up.sql</span></span>
<span class="line"><span>        │         │     └── migration.go</span></span>
<span class="line"><span>        │         ├── model               //数据模型</span></span>
<span class="line"><span>        │         │     └── user.go</span></span>
<span class="line"><span>        │         ├── repo                //仓库</span></span>
<span class="line"><span>        │         │     └── user.go</span></span>
<span class="line"><span>        │         └── seed                //数据填充</span></span>
<span class="line"><span>        │               └── user.go</span></span>
<span class="line"><span>        └── module.go                     //模块入口</span></span></code></pre></div><h3 id="数据操作相关" tabindex="-1">数据操作相关 <a class="header-anchor" href="#数据操作相关" aria-label="Permalink to &quot;数据操作相关&quot;">​</a></h3><p>在这个例子中数据模型与领域实体相似，但在实际项目中，一个领域实体也可能由多个数据模型的数据组成。 业务逻辑只使用领域实体，所以在通过仓库对数据做操作时，仓库会帮我们进行双向转换。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>仓库内置了简单的转换逻辑，但无法满足复杂情况。这时就需要自定义转换逻辑。</p></div><h3 id="数据迁移" tabindex="-1">数据迁移 <a class="header-anchor" href="#数据迁移" aria-label="Permalink to &quot;数据迁移&quot;">​</a></h3><p>框架内置的 migration 模块使用 github.com/golang-migrate/migrate 包实现迁移。 这同样需要在模块入口中注册(module/user/module.go:41)。程序启动后，数据表会自动创建到数据库。</p><h3 id="数据填充" tabindex="-1">数据填充 <a class="header-anchor" href="#数据填充" aria-label="Permalink to &quot;数据填充&quot;">​</a></h3><p>框架内置了数据填充，原理很简单，就是利用容器执行函数。 这同样需要在模块入口中注册(module/user/module.go:42)。 程序启动后，数据会自动填充到数据库。</p><h3 id="user-handler" tabindex="-1">user handler <a class="header-anchor" href="#user-handler" aria-label="Permalink to &quot;user handler&quot;">​</a></h3><p>在 user handler 中，我们添加了两个方法，一个是创建用户的方法，一个是获取用户信息的方法。 与第一个例子一样，我们在 module.go 中也新注册了两个路由。</p><p>您会发现这两个新方法与第一个例子中的方法的返回值数量不一样。 这正是框架的另一个特性，handler函数的可变参数和返回值。 框架允许您为每个handler函数设计自己的参数和返回值。 对于参数，框架会遍历参数列表，查找容器中的对象(依赖注入)或者解析请求的参数。 对于返回值，框架会遍历返回值列表，来决定如何返回响应。</p><h2 id="添加grpc服务" tabindex="-1">添加grpc服务 <a class="header-anchor" href="#添加grpc服务" aria-label="Permalink to &quot;添加grpc服务&quot;">​</a></h2><p>克隆代码到本地</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -b</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> step3</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --single-branch</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git@github.com:zeddy-go/quickstart.git</span></span></code></pre></div><p>我们在上面的项目的基础上添加grpc服务，这样我们的服务不仅能服务http也能同时服务grpc，还能展示代码重用的特性。 当然，如果您的项目只需要基于grpc，您完全可以不用理会http相关的代码。</p><p>项目目录结构如下:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>.</span></span>
<span class="line"><span>├── conf</span></span>
<span class="line"><span>│    ├── config.go</span></span>
<span class="line"><span>│    └── config.yaml</span></span>
<span class="line"><span>├── docker-compose.yaml</span></span>
<span class="line"><span>├── go.mod</span></span>
<span class="line"><span>├── go.sum</span></span>
<span class="line"><span>├── main.go</span></span>
<span class="line"><span>├── module</span></span>
<span class="line"><span>│       └── user</span></span>
<span class="line"><span>│             ├── domain</span></span>
<span class="line"><span>│             │       ├── contract.go</span></span>
<span class="line"><span>│             │       ├── svc</span></span>
<span class="line"><span>│             │       │     └── user.go</span></span>
<span class="line"><span>│             │       └── user.go</span></span>
<span class="line"><span>│             ├── iface</span></span>
<span class="line"><span>│             │       ├── grpc</span></span>
<span class="line"><span>│             │       │     └── user.go            //grpc接口实现</span></span>
<span class="line"><span>│             │       └── http</span></span>
<span class="line"><span>│             │           ├── payload.go</span></span>
<span class="line"><span>│             │           └── user.go</span></span>
<span class="line"><span>│             ├── infra</span></span>
<span class="line"><span>│             │       ├── migration</span></span>
<span class="line"><span>│             │       │     ├── 20240408063653_create_users_table.down.sql</span></span>
<span class="line"><span>│             │       │     ├── 20240408063653_create_users_table.up.sql</span></span>
<span class="line"><span>│             │       │     └── migration.go</span></span>
<span class="line"><span>│             │       ├── model</span></span>
<span class="line"><span>│             │       │     └── user.go</span></span>
<span class="line"><span>│             │       ├── repo</span></span>
<span class="line"><span>│             │       │     └── user.go</span></span>
<span class="line"><span>│             │       └── seed</span></span>
<span class="line"><span>│             │             └── user.go</span></span>
<span class="line"><span>│             └── module.go</span></span>
<span class="line"><span>├── pb                                             //pb文件</span></span>
<span class="line"><span>│    ├── user_grpc.pb.go</span></span>
<span class="line"><span>│    └── user.pb.go</span></span>
<span class="line"><span>├── readme.md</span></span>
<span class="line"><span>└── user.proto                                     //proto文件</span></span></code></pre></div><p>在 main.go 文件中，我们添加内置的 grpc 模块(main.go:21)。 而注册我们自己的服务，只需在 module/user/module.go 文件中从容器中拿到已实例化好的 *grpc.Server 即可(module/user/module.go:44,module/user/module.go:65)。另外，您可以看到，在grpc接口实现文件里面，我们重用了 <code>userService</code> 。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>您完全可以将您的常用代码以<code>模块</code>的形式固化起来。</p></div><p>容器中的每个对象默认为单例模式，得益于常驻内存，已实例化的对象将不再重复实例化，这对执行效率来说是一件好事。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>github.com/zeddy-go/zeddy/errx 包默默的收集了错误栈，您可以使用这样的代码来打印它 fmt.Printf(&quot;%#v&quot;, err) 。 并且，这些信息在经过grpc传输后也不会丢失。</p></div>`,39),i=[l];function t(c,o,r,h,d,g){return n(),a("div",null,i)}const m=s(e,[["render",t]]);export{k as __pageData,m as default};
