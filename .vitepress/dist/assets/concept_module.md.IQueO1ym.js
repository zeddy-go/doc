import{_ as s,D as i,c as n,b as d,w as e,a3 as l,a2 as o,o as t,I as r,a as c}from"./chunks/framework.C9InrCCS.js";const E=JSON.parse('{"title":"module","description":"","frontmatter":{},"headers":[],"relativePath":"concept/module.md","filePath":"concept/module.md"}'),h={name:"concept/module.md"},p=o(`<h1 id="module" tabindex="-1">module <a class="header-anchor" href="#module" aria-label="Permalink to &quot;module&quot;">â€‹</a></h1><p>In Zeddy, a module is the smallest unit that the framework can control. When a struct implements the <code>github.com/zeddy-go/zeddy/app.Module</code> interface, it becomes a module. The framework determines how to utilize a module based on whether it implements <strong>specific</strong> interfaces. As for how to organize the content within the module, you have complete freedom to do so as you see fit. Additionally, you are fully capable of writing the module as an independent <code>Go module</code> and importing it remotely when necessary.</p><p>The following code defines a module:</p><div class="language-go vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    &quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">github.com/zeddy-go/zeddy/app</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Module</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> struct</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	app</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Module</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>In <code>github.com/zeddy-go/zeddy/app/contract.go</code>, we have defined several interfaces that can be implemented for modules. These interface methods are the means by which the framework interacts with the modules. When the framework initializes, it iterates through all modules and attempts to invoke methods in the following order:</p>`,5),m=o('<p>The <code>Init</code> method and <code>Boot</code> method are primarily for initializing the module, and splitting them into two methods is to reduce the dependency of each module on the execution order.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>The concept is straightforward: since the framework executes all <code>Init</code> methods before proceeding to the <code>Boot</code> methods, you should concentrate on binding the <code>New</code> methods of objects (commonly referred to as providers) in the <code>Init</code> methods that are executed earlier in the sequence. Then, in the <code>Boot</code> methods, which are executed later, you retrieve the necessary objects from the container to perform the corresponding operations. This approach helps avoid issues that could arise from dependencies not being instantiated or having their <code>provider</code> not yet bound.</p></div><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>Attentive as you are, you should have noticed that dependencies between modules cannot be completely eliminated. For example, if the configx module is not executed first, other modules may report errors.</p></div><p><code>Start</code> and <code>Stop</code> are the places where blocking logic runs, such as starting an HTTP service. Upon startup, the framework will execute all Start methods in a goroutine, and upon exit, the framework will execute all Stop methods, then wait for all Start methods to exit.</p><div class="danger custom-block"><p class="custom-block-title">DANGER</p><p>Please ensure that your Start method can exit properly; otherwise, the framework will not be able to exit either.</p></div>',5);function u(k,g,f,y,_,b){const a=i("Mermaid");return t(),n("div",null,[p,(t(),d(l,null,{default:e(()=>[r(a,{id:"mermaid-13",class:"mermaid",graph:"flowchart%20TD%0A%20%20%20%20A%5BInvoke%20all%20%60Initable.Init%60%5D%20--%3E%20B%5BData%20Migration%20and%20Data%20Seeding%5D%3B%0A%20%20%20%20B%20--%3E%20C%5BInvoke%20all%20%60Bootable.Boot%60%5D%3B%0A%20%20%20%20C%20--%3E%20D%5BInvoke%20all%20%60Startable.Start%60%5D%3B%0A%20%20%20%20D%20--%20Framework%20Shutdown%20--%3E%20F%5BInvoke%20all%20%60Stopable.Stop%60%5D%3B%0A"})]),fallback:e(()=>[c(" Loading... ")]),_:1})),m])}const v=s(h,[["render",u]]);export{E as __pageData,v as default};
